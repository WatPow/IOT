# Introduction et définition de l'IoT

## Définition de l’IoT
L’**Internet of Things (IoT)** désigne l’**interconnexion via Internet d’objets physiques dotés de capacités de calcul**. La définition donnée par l’Oxford Dictionary est « *The interconnection via the Internet of computing devices embedded in everyday objects, enabling them to send and receive data* ». En d’autres termes plus simples, l’IoT représente *l’interface entre le monde physique et le monde numérique* : des objets courants équipés de capteurs, d’actionneurs et de connectivité peuvent collecter des données et communiquer via le réseau.

## Domaines d’application
L’IoT trouve des applications dans de nombreux domaines variés :
- **Domotique (maison connectée)** – par ex. gestion des lumières, thermostat intelligent, appareils électroménagers communicants.
- **Santé** – dispositifs médicaux connectés et télésanté (bracelets de suivi d’activité, pacemakers, pompes à insuline communicantes, systèmes d’appel d’urgence eCall).
- **Industrie et logistique** – automatismes industriels, suivi de flotte de véhicules ou d’équipements (Industrie 4.0), capteurs sur les chaînes de production, distributeurs intelligents.
- **Sport et loisirs** – objets connectés pour le quantified self, capteurs de performance sportive, équipements de fitness connectés .
- **Énergie** – compteurs intelligents (smart meters) pour le suivi de consommation, gestion optimisée du réseau électrique (smart grids) .
- **Automobile** – véhicules connectés échangeant des données (infodivertissement, navigation) et véhicules autonomes s’appuyant sur des capteurs et communications en temps réel .
- **Autres** – villes intelligentes (Smart City), agriculture connectée (agritech), commerce (retail intelligent), etc.

## Croissance du nombre d’objets connectés
Le nombre d’objets IoT explose et devrait atteindre des niveaux très élevés dans les années à venir. Les projections tablent sur **des dizaines de milliards d’objets connectés d’ici 2030**. Par exemple, Gartner estime qu’il y aura plus de **30 milliards d’objets IoT en 2025**, et certaines projections anticipent environ **50 milliards d’objets connectés en 2030**. Concrètement, cela correspond à plus de **100 nouveaux objets connectés mis en service chaque seconde** dans le monde. Cette prolifération rapide s’accompagne malheureusement de défis en matière de sécurité, comme en témoigne le fait que **84 % des organisations ayant déployé des solutions IoT ont déjà subi une faille de sécurité liée à l’IoT**. La sécurisation de ces objets et de leurs données est donc un enjeu critique dès l’introduction de l’IoT.

# Sécurité de l’IoT

## Objectifs de la sécurité IoT
Comme pour tout système d’information, la sécurité des objets connectés vise d’abord à préserver les trois piliers **CIA** : **Confidentialité, Intégrité et Disponibilité** des données et services, et ce *« en permanence »* (quelle que soit la durée de vie de l’objet). Au-delà de ces principes fondamentaux, le contexte IoT amène des objectifs supplémentaires spécifiques :

- **Éviter la contrefaçon** : s’assurer qu’un objet ou ses composants ne puissent être copiés ou usurpés (garantir l’authenticité de l’appareil).
- **Protéger la propriété intellectuelle** : empêcher qu’un tiers ne vole ou duplique le savoir-faire embarqué (code embarqué, modèles, données sensibles).
- **Empêcher le piratage du firmware** : éviter toute altération ou falsification non autorisée du logiciel interne de l’objet (tampering), que ce soit via une mise à jour malveillante ou une modification physique
- **Prévenir le détournement d’usage (repurposing)** : ne pas permettre qu’un objet soit utilisé à des fins non prévues ou malveillantes (exemple : transformer un capteur anodin en outil d’attaque).
- **Garantir l’intégrité des données et des commandes** : les mesures et messages émis par l’objet ne doivent pas pouvoir être modifiés ou falsifiés par un attaquant. De même, les commandes reçues par l’objet doivent être authentiques et non altérées.
- **Protéger la vie privée** : éviter les fuites de données personnelles ou sensibles collectées par les objets (caméras, microphones, capteurs médicaux…), et empêcher la surveillance indésirable des utilisateurs via leurs objets connectés.

Atteindre ces objectifs de sécurité IoT est indispensable pour **tenir la confiance des utilisateurs** et **protéger les personnes, les données et les marques** associées aux produits IoT.

## Exemples de menaces et vulnérabilités
Les objets connectés sont exposés à de nombreuses **menaces** et présentent parfois des **vulnérabilités** exploitables par des attaquants. En voici quelques exemples marquants :

- **Attaques par déni de service (DoS)** : un attaquant peut tenter de **saturer l’objet ou le service IoT** en lui envoyant une énorme quantité de requêtes ou de messages. Par exemple, inonder un objet de messages via MQTT peut épuiser ses ressources et le rendre indisponible ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Device%20DoS%20,flood%20device%2C%20disconnect%20with%20clientID)). De même, saturer le broker ou le backend cloud de messages (légitimes ou factices) peut provoquer un DoS à plus grande échelle ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Ramsonware%20,or%20system%20data%20%2F%20flows)).
- **Rançongiciel (ransomware)** : comme sur un PC, un malware peut chiffrer les données d’un objet connecté ou le bloquer, puis exiger une rançon. Ce scénario a déjà été observé sur des systèmes IoT, rendant l’appareil inutilisable jusqu’au paiement ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Device%20DoS%20,flood%20device%2C%20disconnect%20with%20clientID)) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Ramsonware%20,or%20system%20data%20%2F%20flows)).
- **Prise de contrôle à distance** : si un attaquant exploite une faille (ex. mot de passe par défaut, buffer overflow dans le firmware), il peut **obtenir un accès non autorisé** à l’objet. Il pourrait alors en prendre le contrôle, par exemple allumer/éteindre un dispositif à distance, intercepter ses données, ou s’en servir comme point d’entrée dans le réseau local.
- **Exploitation de failles logicielles dans le temps** : la durée de vie des objets IoT étant longue, de nouvelles vulnérabilités peuvent apparaître après leur déploiement. Sans mises à jour, un attaquant peut **tirer parti d’une faille découverte ultérieurement** pour compromettre l’appareil des mois ou années après son installation ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Unavailability%20%28e,down)).
- **Atteinte à la vie privée** : la compromission d’un objet peut mener à de la **surveillance illicite**. Par exemple, le piratage d’une caméra connectée ou d’une enceinte vocale permettrait à un intrus d’espionner des conversations ou des images privées. De même, des capteurs de santé piratés pourraient révéler des données médicales sensibles.
- **Botnets IoT** : une fois compromis, des objets connectés peuvent être enrôlés dans un botnet (réseau d’appareils zombies). Des malwares comme *Mirai* ont ainsi infecté des caméras et routeurs IoT à grande échelle, les détournant pour lancer des attaques DDoS massives sur des sites web. Ce type de menace profite du grand nombre d’objets souvent mal sécurisés.

Ces exemples illustrent la diversité des risques : sans mesures adaptées, un objet connecté peut devenir à la fois une **cible** (vol de données, sabotage) et une **arme** (relais d’attaque) pour des hackers.

## Mécanismes de sécurité recommandés
Pour se prémunir contre ces menaces, une **défense en profondeur** doit être mise en place dans les solutions IoT. Les bonnes pratiques de sécurité IoT incluent notamment :

- **Authentification renforcée** – S’assurer que **chaque appareil et chaque utilisateur sont correctement authentifiés** avant d’accéder aux services. Il faut éviter les identifiants par défaut et utiliser des mots de passe robustes ou, mieux, des certificats uniques par appareil ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Secure%20RPI%20user%20access,no%20default%20user%2Fpassword%2C%20close)). Par exemple, désactiver les comptes par défaut (login *pi/raspberry* sur Raspberry Pi) et définir des identifiants uniques empêche un pirate d’accéder facilement à l’objet ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Secure%20RPI%20user%20access,no%20default%20user%2Fpassword%2C%20close)). De même, une authentification au niveau application (pour l’utilisateur final, ex. accès à une interface web de l’objet) doit être en place.
- **Intégrité du logiciel et du matériel** – Mettre en œuvre des mécanismes garantissant que l’appareil ne fonctionne qu’avec un **code de confiance**. Cela passe par un **secure boot** (le démarrage sécurisé vérifie la signature du firmware) et des mises à jour signées numériquement ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Encrypt%20SD%20card%20,device%20unique%20identifier%20%2F%20OTP)). Ainsi, on évite qu’un attaquant installe un firmware altéré. Il est aussi conseillé de **chiffrer le stockage local** (ex. carte SD chiffrée) pour empêcher la modification ou la lecture des données en cas de vol de l’appareil ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Include%20a%20Kensington%20lock,opening)).
- **Confidentialité des communications et des données** – Toujours **chiffrer les échanges réseau** entre l’objet et le serveur (par ex., utiliser TLS pour MQTT ou HTTPS pour les API REST). Le chiffrement empêche un espion d’intercepter des informations sensibles ou de voler des identifiants sur le réseau ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Secure%20the%20dashboard%20access,authn%2C%20change%20port%20number)). De plus, les données stockées dans le cloud ou les bases doivent être protégées (chiffrement côté serveur ou base de données sécurisée) pour éviter les fuites.
- **Contrôle d’accès strict** – Appliquer le principe du **moindre privilège** : un appareil ou utilisateur IoT ne devrait avoir accès qu’aux ressources nécessaires. Au niveau du broker MQTT, on peut par exemple restreindre chaque objet à certains topics. Il faut **fermer les interfaces non utilisées** et protéger celles nécessaires : désactiver les ports ouverts par défaut, sécuriser l’accès SSH (mot de passe robuste ou clés, ou même désactiver SSH si non indispensable) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Secure%20RPI%20user%20access,no%20default%20user%2Fpassword%2C%20close)), sécuriser l’accès aux interfaces web locales (ex: interface Node-RED ou dashboard utilisateur protégés par mot de passe) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Secure%20SSH%20access%20,default%20user%2Fpassword%20%2C%20close)) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Secure%20the%20dashboard%20access,authn%2C%20change%20port%20number)), etc.
- **Utilisation de canaux et services sécurisés** – Éviter d’exposer l’objet sur des services publics non sécurisés. Par exemple, il vaut mieux utiliser un **broker MQTT privé** ou un service cloud sécurisé au lieu d’un broker public ouvert à tous ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Secure%20input%2Foutput%20data%20flows,who%20publishes%20on%20which%20topic%E2%80%A6)). Avec un broker privé, on peut mettre en place une **authentification mutuelle** (certificat client côté objet et certificat serveur côté broker, i.e. MQTT over TLS avec certificats, aussi appelé mTLS) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Secure%20input%2Foutput%20data%20flows,who%20publishes%20on%20which%20topic%E2%80%A6)). Cela garantit que seul l’appareil légitime communique avec le broker et vice-versa.
- **Supervision et maintenance régulière** – Surveiller l’activité du système permet de détecter des comportements anormaux (p. ex. un volume de messages inhabituel pouvant indiquer une tentative d’attaque) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20%E2%80%A6)). Des **logs** doivent être activés sur l’appareil et le serveur, et faire l’objet d’analyses ou d’alertes en cas d’événements suspects. Par ailleurs, il est crucial de **maintenir à jour** le firmware des objets et les services cloud tout au long de leur vie ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Protect%20device%20%26%20infrastructure,use%20mTLS%20and%20private%20broker)). Chaque mise à jour doit être diffusée de manière sécurisée (idéalement signée, et vérifiée par l’objet) et un processus de correction des failles de sécurité doit être planifié dès le départ. Des **audits de sécurité** et tests d’intrusion (pentests) périodiques sont également recommandés pour évaluer la robustesse de la solution ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=17)).

En combinant ces différents mécanismes, on améliore significativement la **résilience** de l’ensemble de l’écosystème IoT face aux attaques. La sécurité IoT doit être envisagée globalement, dès la conception, afin d’éviter qu’une vulnérabilité exploitable compromise le système à n’importe quel niveau.

# Architecture d’une solution IoT typique

## Composants d’une solution IoT
Une solution IoT complète ne se limite pas à l’objet connecté lui-même, mais comporte **plusieurs couches** interdépendantes. Typiquement, on retrouve :

- **Objets connectés (périphérie)** – Ce sont les dispositifs physiques équipés de capteurs et/ou d’actionneurs. Ils mesurent des paramètres du monde réel (température, mouvement, position, etc.) ou agissent physiquement (allumer un LED, piloter un moteur…). Chaque objet embarque un microcontrôleur ou un mini-ordinateur qui gère la logique locale et la communication réseau.
- **Passerelles (gateways)** – Dans certains cas, les objets ne se connectent pas directement à Internet. Une passerelle (par ex. un concentrateur local, une box internet, un smartphone) sert de **relai** entre des objets communiquant en local (Bluetooth, Zigbee, etc.) et le réseau étendu (Internet). La passerelle agrège les données de plusieurs capteurs et les transmet au cloud, et inversement route les commandes du cloud vers les objets.
- **Réseau et connectivité** – C’est l’infrastructure de communication reliant les objets au serveur distant. Il peut s’agir de réseaux sans fil (Wi-Fi domestique, réseaux mobiles 3G/4G/5G, réseaux longue portée basse conso comme LoRa ou Sigfox, etc. ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Cellular))) ou filaires (Ethernet). Parfois, un **réseau maillé local** (Zigbee, Z-Wave, Bluetooth LE…) connecté via une passerelle est utilisé ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Via%20a%20GW%20%E2%80%A2,Wave%20%E2%80%A2%20BLE%20%E2%80%A2%20Matter)). La connectivité doit être disponible et fiable pour assurer le bon échange de données entre les périphériques et le cloud.
- **Plateforme serveur / cloud (backend)** – Il s’agit de la partie **côté serveur** qui reçoit les données des objets, les stocke, les analyse et permet d’envoyer des commandes en retour. Souvent, c’est un service cloud (par ex. AWS IoT, Azure IoT, ou un serveur MQTT/HTTP hébergé) qui assure le rôle de **cerveau central**. Le backend expose éventuellement des API pour consulter les données ou contrôler les objets. Il peut aussi héberger de l’intelligence (analyses, machine learning) exploitant les données IoT collectées.
- **Application cliente / Interfaces utilisateur** – Enfin, l’utilisateur interagit avec le système via une application. Cela peut être une application mobile, un site web, un tableau de bord ou même un assistant vocal. L’interface utilisateur communique avec le backend (directement ou via une API) pour présenter les informations collectées (mesures, alertes) et permettre à l’utilisateur d’envoyer des commandes aux objets (par ex. bouton dans l’appli pour allumer une lampe connectée).

En résumé, l’objet IoT **n’est jamais « tout seul »** : il fait partie d’un **écosystème** comprenant le réseau et des services distants ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Typical%20IoT%20solution%20architecture%20The,not%20limited%20to%20object%20security)). Lorsqu’on conçoit l’architecture d’une telle solution, il faut considérer chaque composant et leurs interactions.

## Défis de sécurité associés
La présence de ces multiples couches rend la **sécurité IoT particulièrement complexe**, car une faille à **n’importe quel niveau** peut compromettre l’ensemble. Par exemple : une vulnérabilité sur l’objet (physiquement accessible) peut donner à un attaquant un point d’entrée vers le réseau interne ou les données cloud ; à l’inverse, une faiblesse sur le serveur (ex. API mal protégée) peut permettre à un hacker d’envoyer de fausses commandes aux objets ou d’exfiltrer des données sensibles.

Un des défis majeurs est la **pluridisciplinarité** de l’IoT. Les équipes impliquées ont des compétences diverses : d’un côté les ingénieurs embarqués qui développent l’objet et, de l’autre, les développeurs cloud/serveur. Or, **chacune de ces équipes ignore souvent les contraintes et bonnes pratiques de l’autre domaine** ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Challenges%20%3A%20Server%20team%20does,not%20know%20embedded%20device%20constraints)). Par exemple, une équipe IT pourrait méconnaître les limitations hardware (CPU, mémoire, énergie) de l’objet et proposer des solutions inapplicables en pratique. Inversement, une équipe électronique pourrait négliger des mesures de cybersécurité essentielles côté serveur ou réseau. Ce silo peut mener à des erreurs de conception (ex : protocole trop lourd pour l’objet, ou absence de chiffrement car jugé trop complexe sur MCU) qui affaiblissent la sécurité globale.

Il est donc crucial d’adopter une **approche globale de la sécurité**. Cela signifie :
- Impliquer dès le départ des expertises complémentaires (sécurité informatique, développement logiciel, ingénierie système embarqué).
- Veiller à ce que les mécanismes de sécurité couvrent **tous les maillons de la chaîne** : sécurisation de l’objet (physique et logiciel), sécurisation des communications réseau, sécurisation du backend cloud et des données stockées, sécurisation des applications clientes.

On doit également prendre en compte les **spécificités de l’IoT** : les objets ont des ressources limitées, une accessibilité physique par des tiers, et une longue durée de vie, ce qui rend impératif le **maintien des protections dans le temps** (gestion des mises à jour, revocation de clés en cas de compromission, etc.). En bref, la sécurité IoT requiert de la **collaboration interdisciplinaire** et une **vision end-to-end**, faute de quoi des failles peuvent subsister aux interfaces entre les composants.

# Problématiques et contraintes métier de l’IoT

Le déploiement de solutions IoT dans la vie réelle s’accompagne de nombreuses contraintes **métier** et **techniques** qu’il faut intégrer dès la conception. Parmi les principales contraintes :

- **Coûts et ressources limitées** : Les projets IoT cherchent souvent à minimiser les coûts, tant au niveau du matériel que de l’exploitation. Cela signifie que les objets embarquent généralement des microcontrôleurs peu onéreux, donc **limités en puissance de calcul, en mémoire et en fonctionnalités** (pas de CPU puissant ni d’OS lourd) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Power%20consumption%20considerations%20may,be%20vital)). Ces limites matérielles restreignent les traitements locaux et parfois les possibilités de sécurité (crypto, stockage). De plus, l’utilisation de services cloud engendre des coûts d’infrastructure proportionnels au nombre d’appareils et au volume de données, qu’il faut contrôler ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Computing%20resources%20may%20be,price)).
- **Bande passante réseau réduite** : De nombreux objets communiquent via des réseaux à faible débit (par ex. réseaux LPWAN comme Sigfox ou LoRa, communications intermittentes sur GSM) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Network%20bandwidth%20may%20be,limited)). Même en Wi-Fi, il peut y avoir des contraintes de réseau local partagé. On doit donc **optimiser la quantité de données échangées** (formats compacts, envoi périodique raisonné) pour s’adapter à ces canaux étroits.
- **Consommation d’énergie** : Beaucoup d’objets IoT fonctionnent sur batterie ou énergie limitée. La **consommation électrique** est un facteur critique : chaque transmission radio ou calcul intensif peut vider la batterie. Il faut alors privilégier des composants basse consommation et minimiser le temps de communication. Cette contrainte peut entrer en conflit avec la sécurité (chiffrement, communications fréquentes pour échange de clés, etc. consomment de l’énergie) – il faut trouver un équilibre ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Network%20bandwidth%20may%20be,limited)).
- **Environnement physique et accessibilité** : Les objets connectés sont souvent déployés *in situ*, dans des lieux où ils peuvent être **facilement accessibles par des tiers** (par exemple dans la rue, à domicile chez un client, sur une machine dans une usine) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Cloud%20operation%20cost%20may,be%20under%20pressure)). Contrairement à un serveur dans un data center sécurisé, *n’importe qui* peut potentiellement manipuler un capteur IoT, tenter de l’ouvrir, d’en extraire la carte SD ou de le voler. L’environnement peut être hostile (température, humidité, vandalisme). Il faut donc prendre en compte la **sécurité physique** (boîtier scellé, vis anti-sabotage, détection d’ouverture…) pour protéger l’appareil.
- **Comportement des utilisateurs** : L’utilisateur final ou le client peut avoir un impact sur le dispositif IoT. Par exemple, un utilisateur peut **détourner l’usage** prévu de l’objet ou le connecter de manière non sécurisée. Il peut négliger d’installer les mises à jour de sécurité, ou au contraire chercher à « hacker » son propre appareil (pour l’optimiser ou en enlever les limitations), introduisant des risques supplémentaires ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Devices%20are%20usually%20easily,to%20anyone%20to%20tamper%20with)). Il faut anticiper ces usages non prévus et sensibiliser les utilisateurs (ou implémenter des verrouillages quand nécessaire).
- **Durée de vie prolongée des appareils** : Contrairement aux smartphones remplacés tous les 2-3 ans, de nombreux objets industriels ou infrastructurels sont installés pour **10, 15 ans ou plus** ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20User%20may%20act%20against,the%20product)). Cela signifie que la technologie évoluera autour d’eux (protocoles réseaux, algorithmes de sécurité) tandis qu’ils continueront de fonctionner. Ils devront peut-être s’adapter à de nouvelles exigences (par ex., passage à IPv6, ou remplacement d’un algorithme de chiffrement devenu obsolète). **La longévité pose aussi un problème de maintenance** : comment déployer des correctifs à grande échelle sur des objets disséminés sur le terrain pendant une décennie ? La planification du cycle de vie (mises à jour OTA, support à long terme) est donc une contrainte clé dans l’IoT.

En résumé, un projet IoT doit naviguer entre **des exigences parfois contradictoires** : offrir plus de fonctionnalités et de connectivité, tout en consommant peu d’énergie, en utilisant du matériel bon marché, sur des réseaux limités, et en garantissant la sécurité malgré un accès physique non contrôlé et une longue durée de vie. Ces contraintes expliquent pourquoi la sécurité IoT est souvent un défi – elle doit être adaptée *sur mesure* aux réalités du terrain ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Network%20bandwidth%20may%20be,limited)) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Devices%20are%20usually%20easily,to%20anyone%20to%20tamper%20with)).

# Choix techniques à considérer pour un projet IoT

La conception d’un projet IoT implique de **nombreux choix techniques initiaux** qui orienteront le développement. Dès le départ, l’équipe doit décider : *Quel matériel utiliser ? Quel système d’exploitation embarqué ? Quelle connectivité et quels protocoles de communication adopter ? Faut-il s’appuyer sur une plateforme cloud ou développer une solution locale ?* ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=All%20starts%20with%20a%20lot,of%20choices%E2%80%A6)). Ces décisions sont cruciales, car elles doivent équilibrer contraintes techniques, coûts, et exigences du cas d’usage.

## Matériel (Raspberry Pi, microcontrôleur…)
Le **choix du hardware** détermine les capacités de l’objet connecté. Deux grandes options existent :
- **Systèmes embarqués « complets »** : par ex. une carte Raspberry Pi, un BeagleBone ou autre nano-ordinateur capable d’exécuter un OS comme Linux. Ces plateformes offrent davantage de puissance de calcul, de mémoire et de fonctionnalités (connectivité Wi-Fi/Ethernet intégrée, ports USB, etc.). Elles facilitent le développement (on peut coder en Python, utiliser des services existants) et la mise en place de mécanismes de sécurité complexes. En contrepartie, elles consomment plus d’énergie et coûtent plus cher.
- **Microcontrôleurs (MCU)** : par ex. une carte Arduino, un module ESP8266/ESP32, un STM32 Nucleo, etc. ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Some%20choices%20have%20already,could%20have%20been%20Arduino%2FNucleo%2FESP8266)). Ces modules sont très économiques et basse consommation, mais beaucoup plus limités en ressources (quelques dizaines de MHz, peu de RAM/stockage). Ils n’exécutent généralement pas Linux mais du code natif ou un petit RTOS. Le développement est plus contraint (souvent en C/C++) et certaines fonctionnalités doivent être implémentées manuellement (pile réseau, crypto...). Toutefois, il existe des microcontrôleurs spécialisés IoT avec des accélérateurs cryptographiques ou des éléments sécurisés (Secure Elements) pour aider à la sécurité.

Le choix dépend du cas d’usage : si l’objet doit faire des traitements locaux avancés ou supporter une pile logicielle lourde, un **nano-ordinateur type Raspberry Pi** est indiqué. S’il doit être très économe, peu coûteux et en grand nombre, un **MCU** sera préféré. Parfois, un compromis consiste à utiliser un SoC intermédiaire (ex: ESP32 qui offre Wi-Fi + assez de RAM pour du SSL). Quoi qu’il en soit, il faut prévoir le hardware en considérant la sécurité : disponibilité d’un **TPM/élément sécurisé** pour stocker des clés, support d’accélération de chiffrement, etc., peuvent influencer la décision.

## Systèmes d’exploitation (Linux, RTOS…)
En parallèle du matériel, le **système d’exploitation (OS)** embarqué doit être choisi. Là aussi, plusieurs catégories :
- **Pas d’OS (bare metal)** : le microcontrôleur exécute une boucle logicielle directement sans couche d’abstraction. C’est le cas des petits Arduino classiques par exemple. Cela offre un contrôle total et une faible overhead, mais complique la gestion de fonctionnalités complexes (pas de multitâche sauf à implémenter un scheduler rudimentaire, gestion manuelle du réseau…).
- **OS temps réel léger (RTOS)** : de nombreux microcontrôleurs IoT adoptent un RTOS (Real-Time Operating System) comme **FreeRTOS**, **ARM mBed OS**, **Zephyr**, etc. ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=IoT%20OSs)). Ces OS apportent un ordonnancement de tâches, des bibliothèques pour la communication (pile TCP/IP, drivers) et parfois des *frameworks* IoT intégrés. Ils sont conçus pour tourner avec très peu de mémoire et pour respecter des contraintes temps réel (délais garantis pour certaines tâches). L’avantage est d’avoir une base logicielle fiable et modulable, tout en restant adapté aux ressources limitées.
- **Linux embarqué** : si le hardware le permet (processeur ARM Cortex-A par ex.), on peut embarquer un OS Linux (comme Raspbian sur Raspberry Pi). Linux offre un écosystème riche, la compatibilité avec de nombreux protocoles et bibliothèques, et la facilité de développement (on peut coder en haut niveau, utiliser Python, Node.js, etc.). Des distributions spécialisées IoT ou minimalistes existent. Cependant, Linux a un empreinte mémoire/stockage bien plus grande et peut introduire des soucis de stabilité temps réel ou de temps de boot.
- **OS spécialisés** : il existe des OS plus rares selon les besoins, par ex. **PikeOS** (système partitionné sûr) pour des applications critiques ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Linux)), ou des OS propriétaires optimisés pour l’IoT.

Le choix de l’OS se fait en fonction des **ressources matérielles disponibles** et des **exigences de l’application**. Un petit capteur sur batterie utilisera plutôt un firmware bare metal ou un RTOS ultra-léger. Un gateway ou un appareil multi-capteurs pourra embarquer Linux pour bénéficier de sa polyvalence. D’un point de vue sécurité, Linux apporte les mécanismes éprouvés (gestion d’utilisateurs, droits, mises à jour facilitées) tandis qu’un firmware bare metal offre une surface d’attaque plus réduite mais nécessite de tout implémenter à la main (y compris les sécurités). Souvent, la facilité de déploiement oriente le choix : beaucoup de développeurs prototypent avec Raspberry Pi + Linux pour aller vite, puis éventuellement optimisent vers un MCU/RTOS pour la version industrielle.

## Protocoles de communication (MQTT, CoAP, HTTP…)
Plusieurs **protocoles réseau** sont envisageables pour la communication entre l’objet et la plateforme serveur. Les principaux protocoles applicatifs utilisés en IoT incluent :

- **MQTT (Message Queuing Telemetry Transport)** – Un protocole de messagerie léger basé sur un modèle **Publish/Subscribe**. Les objets envoient des messages (publish) sur des *topics* et reçoivent des messages en s’abonnant (subscribe) à des topics d’intérêt. MQTT est très économe en bande passante et en ressources, utilisant un format binaire simple sur TCP ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Publish%2FSubscribe%20message%20exchange%20transport,protocol)). Il nécessite un **broker** (serveur MQTT) faisant office d’intermédiaire : les clients ne communiquent jamais directement entre eux, tout passe par le broker qui redistribue aux abonnés ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Requires%20a%20broker%20%E2%80%A2,publisher%29%20and%20message%20receivers)). MQTT est idéal pour l’IoT : il a été conçu pour des capteurs contraints et des réseaux instables. Il offre en plus des fonctionnalités utiles (qualité de service des messages 0, 1, 2 ; rétention de messages ; topics hiérarchiques avec wildcards). De nombreux *clouds IoT* le supportent nativement.
- **CoAP (Constrained Application Protocol)** – Un protocole inspiré de HTTP mais allégé, conçu pour les dispositifs contraints et les réseaux à forte latence. CoAP fonctionne généralement sur UDP (plutôt que TCP) pour plus de légèreté. Il utilise un schéma de requête/réponse (comme HTTP REST) mais avec un en-tête binaire très compact, ce qui le rend beaucoup moins verbeux qu’HTTP classique. CoAP convient bien aux architectures *machine-to-machine* simples, et il est souvent utilisé avec l’architecture RESTful (accès à des ressources identifiées par des URI sur l’objet, par ex. `/capteur/temperature`). Il intègre des mécanismes de fiabilité (accusés de réception) malgré UDP, et peut être chiffré via DTLS.
- **HTTP/HTTPS** – Le protocole web classique est aussi utilisé en IoT, surtout lorsque les objets ont la puissance suffisante pour l’embarquer. L’avantage est la **simplicité** et l’interopérabilité : un objet peut envoyer des requêtes HTTP (par ex. POST de ses données JSON vers un serveur web) ou exposer lui-même une API REST accessible en HTTP. Cependant, HTTP est plus **lourd** en overhead (entêtes texte volumineux) et moins adapté aux réseaux limités. Sur des microcontrôleurs, implémenter HTTP et TLS consomme davantage de mémoire. Néanmoins, pour des objets connectés en haut débit (Ethernet, Wi-Fi) et pour réutiliser l’infrastructure web existante, HTTP(S) reste un choix courant.

D’autres protocoles ou standards IoT peuvent être mentionnés selon les besoins : par exemple **WebSockets** (communication bidirectionnelle temps réel sur une base HTTP, utile pour des retours instantanés), **AMQP** (protocole de messagerie orienté broker, plus lourd que MQTT, plutôt pour l’IoT industriel), ou encore des *suites* comme **LwM2M** (Lightweight M2M) qui combinent CoAP et un modèle d’objets pour faciliter la gestion de dispositifs à distance ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=IoT%20communication%20protocols)).

En pratique, **MQTT s’est imposé** pour de nombreux cas d’usage IoT grand public et industriel, grâce à sa légèreté et son modèle pub/sub découplant les émetteurs des récepteurs ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Publish%2FSubscribe%20message%20exchange%20transport,protocol)). CoAP est utilisé dans certains réseaux capillaires (notamment dans les objets contraints type capteurs sur batterie). HTTP reste pertinent pour l’intégration avec le web ou pour des prototypes rapides. Le choix du protocole dépendra donc des contraintes de l’objet (peut-il supporter TCP, TLS ?), du modèle d’échange requis (asynchrone pub/sub vs requête/réponse), et de l’écosystème (compatibilité avec le serveur ou la plateforme choisie). Souvent, les plateformes cloud imposent ou recommandent un protocole supporté (ex: AWS IoT Core privilégie MQTT, d’autres offrent HTTP en alternative pour les objets qui ne peuvent pas faire MQTT).

## Cloud vs solutions sur site
Enfin, un choix structurant pour une solution IoT est **l’infrastructure backend** : va-t-on s’appuyer sur un service cloud existant ou bâtir une solution locale dédiée (*on-premise*) ? ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20What%20authentication%20%26%20encryption,mechanisms)) Chacune des deux approches a ses avantages et inconvénients :

- **Cloud IoT** : Utiliser un cloud public (AWS, Azure, Google Cloud IoT, etc.) permet de bénéficier de **services prêts à l’emploi** : gestion des appareils (device registry), broker MQTT scalable, stockage des données, tableaux de bord, analyses, etc. Par exemple, AWS IoT Core fournit d’emblée une infrastructure fiable pour connecter des millions d’appareils de façon sécurisée. Le cloud offre **évolutivité** (on peut monter en charge facilement) et disponibilité, sans avoir à gérer le matériel serveur. De plus, il s’intègre avec d’autres services (base de données, IA, notification) offrant un écosystème complet. En revanche, le cloud implique des **coûts récurrents** (facturation à l’usage), et une **dépendance vis-à-vis d’un fournisseur** – on confie ses données et la disponibilité du service à un tiers. Des enjeux de **souveraineté des données** ou de confidentialité peuvent également se poser, en particulier dans des secteurs sensibles.
- **Solution sur site (on-premise)** : Cela consiste à héberger soi-même le serveur IoT (par ex. un broker MQTT Mosquitto sur un serveur local, une base de données interne, etc.). L’avantage principal est de garder un **contrôle total** sur l’infrastructure et les données. Aucune donnée ne transite par Internet vers un tiers si tout est local (ce qui peut réduire certains risques de confidentialité et dépendances). Les coûts peuvent être moindres à long terme pour un nombre d’appareils stable (pas de facture cloud, seulement le coût fixe des serveurs). Cependant, cette approche nécessite d’avoir les **compétences** et les ressources pour installer, développer et maintenir l’infrastructure. Il faut gérer la redondance, la sécurité, les mises à jour serveurs, etc. – ce que les clouds mutualisent pour vous. De plus, une solution sur site peut être moins accessible à grande échelle (accès distant pour les utilisateurs nomades, connectivité mondiale si les objets sont déployés sur de nombreux sites géographiques).

En pratique, beaucoup d’initiatives IoT démarrent sur des **solutions cloud** pour profiter de la rapidité de mise en œuvre et de l’**effet plateforme** (outils intégrés) – on parle de démarche MVP (Minimum Viable Product) hébergée dans le cloud pour tester rapidement ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Prototype%20fast)). Par la suite, selon les besoins, on peut rapatrier sur site une partie de la solution ou opter pour un **cloud privé** (hébergé chez soi). L’essentiel est d’évaluer ce choix en fonction de critères de **coût**, de **sécurité** (réglementations, sensibilité des données) et de **compétences disponibles**. Notons qu’il existe des solutions hybrides : par ex. utiliser un cloud public pour la connectivité mais stocker certaines données critiques en local, ou encore déployer des appliances en périphérie (*edge computing*) qui traitent localement une partie des données pour limiter la dépendance au cloud. En résumé, *Cloud vs On-Prem* est un arbitrage entre **commodité/échelle** et **contrôle/souveraineté**, qui doit être tranché en accord avec la stratégie de l’entreprise et les contraintes du projet.

# Projet pratique : Création d’une lampe connectée

Dans le cadre du cours, un **projet pratique** a été réalisé pour appliquer concrètement ces notions : la création d’une **lampe connectée intelligente** (smart lamp). L’objectif était de monter un prototype de lampe pilotable localement et à distance, avec une interface web et même un contrôle vocal, en mettant l’accent sur la sécurité à chaque étape. Voici les grandes étapes de ce projet :

## Installation et configuration du Raspberry Pi
On a choisi d’utiliser un **Raspberry Pi** comme cœur de la lampe (ce choix de matériel a été posé dès le départ pour le prototype, bien qu’une version finale aurait pu utiliser un microcontrôleur plus simple) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Some%20choices%20have%20already,could%20have%20been%20Arduino%2FNucleo%2FESP8266)). La première étape a consisté à préparer le Raspberry Pi : on a **installé le système d’exploitation Raspbian (Raspberry Pi OS)** sur une carte SD. Pour cela, l’outil Raspberry Pi Imager a été utilisé avec l’image officielle du système ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Preparing%20RPI%20for%20remote%20access)).

Une fois le système copié, on a inséré la carte SD et démarré le Pi. **L’accès SSH a été activé** pour pouvoir configurer le Pi sans écran (mode headless) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Activate%20ssh%20in%20imager,partition%20or%20change%20RPI%20config)). Cela s’est fait soit via l’option dédiée dans l’Imager, soit manuellement en plaçant un fichier vide nommé `ssh` à la racine de la partition boot sur la carte SD avant le premier démarrage. Ainsi, on peut se connecter à distance en ligne de commande. On a également configuré la **connexion réseau Wi-Fi** en créant un fichier de configuration `wpa_supplicant.conf` (contenant le SSID et mot de passe du réseau sans fil) dans la partition de boot ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Configure%20Wifi%20in%20imager,or)). Cette configuration permettait au Raspberry Pi de se connecter automatiquement à internet. Après le démarrage, on s’est connecté en SSH avec les **identifiants par défaut** (login `pi` / mot de passe `raspberry`) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Login)), puis il est recommandé de changer le mot de passe par sécurité.

Côté matériel, on a **assemblé les composants de la lampe** : le Raspberry Pi, une LED (qui simulera l’ampoule de la lampe) et un bouton poussoir (pour contrôler la lampe manuellement). La LED a été branchée sur l’une des broches GPIO du Raspberry Pi (avec une résistance en série), et le bouton sur une autre broche GPIO configurée en entrée (avec une résistance de pull-up/down adaptée) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Let%E2%80%99s%20build%20the%20hardware%20part)). En résumé, à l’issue de cette phase, on disposait d’un Raspberry Pi opérationnel (OS installé, accessible à distance) avec une LED et un bouton connectés à ses broches d’E/S.

## Gestion des GPIO (LED et bouton-poussoir)
La seconde étape a porté sur la **validation de la partie électronique** : il fallait s’assurer qu’on pouvait allumer la LED et lire l’état du bouton via le Raspberry Pi. Pour cela, on a manipulé les **GPIO** (General Purpose Input/Output) du Pi.

Dans un premier temps, on a utilisé un petit script Python en se connectant en SSH. Grâce à la bibliothèque Python `RPi.GPIO`, on peut contrôler les broches programmables. On a écrit un programme qui configure la broche reliée à la LED en **sortie**, puis qui envoie successivement un niveau haut (3.3V) ou bas (0V) sur cette broche ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Set%20GPIO%20to%20output,mode)). Concrètement, un appel à `GPIO.output(pin, GPIO.HIGH)` allume la LED, et `GPIO.output(pin, GPIO.LOW)` l’éteint ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Set%20GPIO%2018%20PIN,to%20low%20or%20high%20current)). En faisant alterner ces états avec une pause d’une seconde (fonction `sleep`), on obtient un **clignotement de la LED** en boucle, ce qui valide que la lampe peut être contrôlée par logiciel ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=GPIO.output%28LED_GPIO%2CGPIO.HIGH%29%20time.sleep%281%29%20print%20%28,LOW)). Ce test (un programme *blink*) est un grand classique pour s’assurer du bon câblage et de la configuration de la bibliothèque GPIO.

De même, on a testé le **bouton poussoir** en configurant la broche correspondante en **entrée** avec résistance de pull-up interne activée. Un court script permettait de lire la valeur de la broche (0 ou 1 selon l’état du bouton) et d’afficher un message lors d’un appui. Cela nous a permis de confirmer que le Raspberry Pi détecte correctement les pressions sur le bouton.

En parallèle du code Python, le projet a introduit l’outil **Node-RED** pour gérer les GPIO de façon plus visuelle. Node-RED est un environnement de programmation par flux (flow-based) accessible via un navigateur web. Dans Node-RED, on a ajouté des **nœuds spécifiques Raspberry Pi** : un nœud d’entrée GPIO configuré sur la broche du bouton, et un nœud de sortie GPIO sur la broche de la LED ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=match%20at%20L995%20%E2%80%A2%20Add,for%20the%20LED%20on%20GPIO18)). En les connectant, on peut lier le bouton à la LED : chaque changement d’état du bouton déclenche automatiquement l’allumage ou l’extinction de la LED. Node-RED offre également des **noeuds “inject”** (pour envoyer manuellement des signaux) et des **noeuds “dashboard”** pour créer une interface utilisateur. On a ainsi pu ajouter deux boutons virtuels (dans une interface web tableau de bord) reliés à la LED : l’un pour allumer, l’autre pour éteindre ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=match%20at%20L995%20%E2%80%A2%20Add,for%20the%20LED%20on%20GPIO18)). En quelques clics, on avait une **interface de contrôle locale** de la lampe, sans avoir encore codé d’application web – Node-RED s’en charge.

À ce stade, le matériel de la lampe était opérationnel et pilotable localement : le Raspberry Pi faisait office de contrôleur, le bouton physique permettait de changer l’état de la lampe, et une LED reflétait cet état (éclairée ou non).

## Programmation en Python et Node-RED
Une fois la communication de base avec la lampe établie, l’étape suivante a consisté à **développer la logique applicative** de la lampe connectée. Deux approches ont été explorées : la programmation par code (Python) et la programmation par flux (Node-RED), chacune ayant ses bénéfices.

Dans un premier temps, on a étendu le **script Python** pour gérer une logique un peu plus avancée : par exemple, alterner l’état de la LED à chaque appui sur le bouton (toggle), ou faire clignoter la lumière en morse. Cela permet d’illustrer comment on pourrait écrire le programme embarqué de l’objet. Toutefois, écrire tout en Python peut devenir complexe pour intégrer d’autres fonctionnalités (comme une interface graphique ou un service web). C’est pourquoi le projet a basculé vers Node-RED pour la suite.

**Node-RED** a été utilisé comme principal outil de construction de l’application IoT de la lampe. Dans Node-RED, on a créé un **flux** représentant le comportement de la lampe :
- Le nœud d’entrée du bouton est relié à un nœud fonction (ou directement à un nœud de sortie) de manière à inverser l’état de la LED à chaque appui.
- Des **nœuds temporisés** peuvent être ajoutés pour, par exemple, éteindre automatiquement la lampe après un certain temps (fonction de minuterie).
- Grâce aux **nœuds Dashboard**, on a construit une petite interface utilisateur web : un bouton “Allumer/Éteindre” qui envoie une commande, et une indication visuelle de l’état actuel de la lampe (par ex. une LED virtuelle verte/rouge). Node-RED héberge ce tableau de bord accessible via un navigateur sur le réseau local du Raspberry Pi.

L’avantage de Node-RED est qu’il permet d’intégrer facilement divers **protocoles et services** sans avoir à coder tout à bas niveau. Par exemple, on peut insérer un nœud HTTP, un nœud MQTT, un nœud base de données, et les relier. Cela a été utile pour les étapes suivantes du projet. Notons que l’équipe a choisi Node-RED justement pour **éviter de développer une application mobile dédiée** et privilégier un accès via le navigateur ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Application%20logic%20will%20be,power%20consumption%20constraints%2C%20no%20BOM)) : cette décision a accéléré le développement (pas de code Android/iOS à écrire) et Node-RED fournit d’emblée un tableau de bord web en LAN.

En résumé, à l’issue de cette phase de programmation, la “smart lamp” disposait d’une logique interne et d’une interface locale : on pouvait appuyer sur le bouton ou cliquer sur l’interface web locale pour allumer/éteindre la LED, et le système pouvait éventuellement effectuer des actions automatiques (timer, etc.) configurées dans Node-RED.

## Ajout de contrôle distant via MQTT
La fonctionnalité suivante à implémenter était le **contrôle à distance** de la lampe, c’est-à-dire la possibilité d’agir sur la lampe depuis l’extérieur du réseau local, voire depuis Internet. Pour ce faire, on a intégré le protocole **MQTT** dans la solution.

Le principe a été le suivant : le Raspberry Pi (et Node-RED) fonctionnent comme un **client MQTT** qui s’abonne à un certain **topic** pour les commandes de la lampe. Par exemple, un topic nommé `lampe/commande` ou `RPI1/lampe/setState`. Lorsqu’un message “ON” ou “OFF” est publié sur ce topic par n’importe quel autre client MQTT, le Raspberry Pi le reçoit et Node-RED déclenche l’allumage ou l’extinction de la LED en conséquence. Inversement, le Raspberry Pi peut publier sur un topic (ex: `lampe/etat` ou `RPI1/lampe/status`) à chaque changement, afin que les clients distants soient informés de l’état actuel de la lampe.

Pour réaliser cela, il a fallu disposer d’un **broker MQTT** accessible par tous les clients (le Raspberry Pi et le client distant). Dans un premier temps, pour simplifier, on a utilisé un **broker public gratuit** comme **Mosquitto** en ligne (par exemple `test.mosquitto.org` sur le port 1883) – ces brokers ouverts permettent de tester sans installer de serveur ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Install%20MQTT%20Box%20desktop,fr%26gl%3Dfr%20%2F%20https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fmqttbox%2Fkaajoficamnjijhkeomgfljpicifbk%20af%3Fhl%3Dfr)). On a configuré Node-RED pour qu’il se connecte à ce broker en tant que client MQTT (Node-RED offre des nœuds “MQTT input” et “MQTT output” prêts à l’emploi). Le nœud MQTT input a été paramétré avec le topic de commande de la lampe et relié au nœud de sortie GPIO de la LED. Ainsi, toute commande reçue sur le broker est transmise au flux Node-RED et agit sur la LED.

Côté utilisateur distant, on pouvait utiliser un outil comme **MQTTBox** sur PC ou smartphone pour se connecter au même broker et envoyer des messages MQTT ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Install%20MQTT%20Box%20desktop,fr%26gl%3Dfr%20%2F%20https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fmqttbox%2Fkaajoficamnjijhkeomgfljpicifbk%20af%3Fhl%3Dfr)). En pratique, en se connectant au broker `test.mosquitto.org` et en publiant le message `ON` sur le topic convenu, on voyait instantanément la LED de la lampe s’allumer à distance. Cela a validé le concept de **pilotage à distance par Internet** grâce à MQTT.

MQTT présente l’avantage d’être léger et **découple l’expéditeur du destinataire** : le Raspberry Pi n’a pas besoin d’être directement exposé sur Internet, c’est le broker qui sert de point central de communication ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Requires%20a%20broker%20%E2%80%A2,publisher%29%20and%20message%20receivers)). Le Pi maintient juste une connexion sortante vers le broker, et peut ainsi recevoir des ordres de n’importe où. De plus, MQTT gère les problèmes de connectivité (si la connexion est perdue, le Pi se reconnectera et pourra récupérer un message *retain* s’il a été marqué comme tel, etc.).

Cette étape a transformé notre lampe locale en **objet connecté à part entière** : on pouvait la contrôler depuis un réseau extérieur via le broker MQTT. On avait ainsi une infrastructure simple : *lampe (Raspberry Pi) ←MQTT→ broker (cloud) ←MQTT→ client distant*.

Enfin, on a aussi fait en sorte de **publier l’état** de la lampe sur un topic MQTT dédié. Ainsi, le client distant pouvait s’abonner et être notifié (par ex. recevoir “ON” ou “OFF” quand quelqu’un appuie sur le bouton physique). Cela permet une synchronisation dans les deux sens.

À ce stade, la “smart lamp” couvrait toutes les fonctionnalités de base : **contrôle local manuel, interface web locale, et contrôle distant via MQTT**. La suite du projet a porté sur l’amélioration de la **sécurité** et l’intégration avec des services cloud plus avancés.

# Sécurité MQTT et bonnes pratiques

L’utilisation de MQTT dans un contexte IoT nécessite de bien comprendre les enjeux de sécurité, notamment quand on utilise des brokers publics ou partagés. Le cours a abordé les **risques liés aux brokers MQTT ouverts** et les **bonnes pratiques pour sécuriser les communications MQTT**. Des exercices pratiques ont également été menés, notamment avec **Wireshark et TCPDump** pour analyser le trafic.

## Vulnérabilités des brokers MQTT publics
Les brokers MQTT publics (tels que `test.mosquitto.org`, `broker.hivemq.com`, etc.) sont très utiles pour tester rapidement, car ils sont ouverts à tous sans inscription. Cependant, ils présentent de **graves vulnérabilités du point de vue sécurité** :

- **Absence d’authentification** : N’importe quel client peut se connecter anonymement sur ces brokers et s’abonner à n’importe quel topic. Il n’y a généralement **aucun contrôle d’accès** par défaut. Un attaquant peut donc écouter des topics courants (souvent les gens testent sur des topics comme “test” ou “dev”) et potentiellement capter des informations sensibles si des utilisateurs y envoient des données privées par inadvertance. Il peut aussi publier des messages malveillants sur des topics utilisés par d’autres.
- **Données en clair sur le réseau** : Souvent, les connexions se font sur le port MQTT standard (1883) qui n’est **pas chiffré**. Les messages circulent donc en clair sur Internet. Via une simple capture réseau, un attaquant peut lire le contenu des messages MQTT échangés sur un broker public. Si des identifiants ou commandes critiques transitent, ils sont exposés. Un exercice a consisté à lancer **TCPDump** sur le port 1883 pour capturer le trafic MQTT ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Wireshark%20or%20TCPDump%20on%20port,1883%E2%80%A6)), puis à publier un message avec nom d’utilisateur et mot de passe en paramètre sur un broker public ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=tcpdump%20port%201883%20%E2%80%93w%20dump,port%3D1883)) – on a pu voir en clair le contenu du message et les identifiants transmis, preuve qu’il n’y a pas de confidentialité sans TLS.
- **Pas de cloisonnement entre clients** : Sur un broker public, un client malveillant peut s’abonner à `#` (wildcard qui reçoit tous les topics) et **espionner l’intégralité du trafic** passant par ce broker. De plus, il peut utiliser un identifiant client identique à celui d’un autre device pour le déconnecter (puisqu’un broker MQTT déconnecte le précédent client si un autre se connecte avec le même ClientID) – c’est une façon de faire du **denial of service ciblé** sur un device ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Note%20%3A%20%E2%80%A2%20A%20single,the%20others%20are%20disconnected)).

En somme, les brokers ouverts sont *intrafiquables* et à utiliser uniquement pour des tests sans données réelles. Dans un contexte de production, laisser des objets se connecter à un broker public représenterait un énorme risque (données lisibles par tous, contrôle possible par des tiers). Le cours a illustré ces vulnérabilités pour bien faire prendre conscience qu’il fallait impérativement passer à des solutions sécurisées.

## Authentification et chiffrement des communications MQTT
Pour sécuriser MQTT, deux axes principaux : **authentifier** les clients et **chiffrer** les échanges. Les bonnes pratiques présentées incluent :

- **Utilisation d’un broker privé ou sécurisé** : Plutôt que d’utiliser un broker public anonyme, déployer son propre broker MQTT ou utiliser un service cloud IoT qui impose une sécurité. Cela permet de **contrôler qui se connecte**. Par exemple, un broker Mosquitto peut être configuré avec une liste d’utilisateurs/mots de passe, ou (mieux) avec des certificats clients. Un service comme AWS IoT Core oblige chaque appareil à présenter un **certificat X.509 valide** pour s’authentifier.
- **Mise en place d’une authentification MQTT** : MQTT supporte l’envoi d’un nom d’utilisateur et mot de passe lors de la connexion (champ `CONNECT`). Sur un broker privé, on configurera donc des **identifiants uniques par appareil**. Cependant, l’envoi de login/password en clair n’est pas suffisant – il doit être couplé à du chiffrement TLS pour ne pas exposer ces credentials sur le réseau. Idéalement, l’utilisation de **certificats** rend l’authentification encore plus robuste (impossibilité de se connecter sans posséder la clé privée de l’appareil). Un bon broker doit aussi implémenter des **ACL (Access Control Lists)** pour n’autoriser chaque client qu’à publier/souscrire à certains topics spécifiques, évitant qu’un appareil puisse interférer avec un autre.
- **Chiffrement via TLS** : Il est indispensable de **chiffrer les communications MQTT** surtout si elles passent par Internet. MQTT peut aisément fonctionner sur TLS (port par défaut 8883). Ainsi, tous les messages sont cryptés et ne peuvent être lus par un intermédiaire. Le cours a montré que sans TLS on peut tout voir dans Wireshark, alors qu’avec TLS, même en capturant le trafic, on ne voit que des données chiffrées. De plus, TLS garantit l’authenticité du serveur (le client vérifie le certificat du broker) et éventuellement l’authenticité du client (si on utilise des certificats clients). On a évoqué l’usage de **MQTTS** (MQTT over SSL/TLS) à privilégier systématiquement.

En résumé, les communications de la lampe connectée auraient dû, dans une version sécurisée, passer par un broker MQTT avec authentification + TLS. C’est d’ailleurs le cas sur les plateformes cloud professionnelles : **AWS IoT exige une connexion TLS avec certificat**, et ne permet pas de se connecter en clair ou anonymement ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Filters%20%26%20distributes%20messages,based%20on%20message%20%E2%80%98topic%E2%80%99)). Cette combinaison d’authentification forte et de chiffrement assure que seuls les clients autorisés échangent, et de façon confidentielle.

## Captures réseau et analyse du trafic MQTT
Pour sensibiliser aux points ci-dessus, le cours a inclus des manipulations avec **Wireshark** et **tcpdump**. Concrètement, après avoir fait échanger des messages MQTT entre la lampe (Raspberry Pi) et le broker public, on a **capturé le trafic réseau** sur le Raspberry Pi en écoutant le port 1883 (port MQTT non sécurisé) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Wireshark%20or%20TCPDump%20on%20port,1883%E2%80%A6)). L’analyse avec Wireshark a permis d’observer dans les paquets :

- Les messages PUBLISH contenant le topic et le payload en clair (on voyait par exemple le texte “HELLO” ou “Message1” envoyé sur le topic de test).
- Les éventuels identifiants envoyés lors du CONNECT (si on avait configuré un user/password dans MQTTBox, ils apparaissaient en clair dans le paquet ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=tcpdump%20port%201883%20%E2%80%93w%20dump,port%3D1883))).

Cet exercice a clairement montré que **sans chiffrement TLS, il n’y a aucune confidentialité** : un attaquant sur le même réseau (ou un administrateur de réseau) peut espionner tout le contenu. Par la même occasion, on voit qu’il serait facile d’injecter un faux message en reproduisant le même format.

Ensuite, on a refait l’essai en se connectant via **MQTTS (port 8883)** sur un broker offrant TLS. Dans ce cas, Wireshark ne permet plus de lire le contenu des paquets (il voit bien le flux TLS mais ne peut le déchiffrer). On comprend donc l’importance du chiffrement.

Enfin, il a été mentionné des outils spécialisés, par exemple **MQTT Explorer** ou **MQTT Spy**, qui permettent de se connecter aux brokers et visualiser les topics de façon arborescente. Ces outils sont pratiques pour le débogage, mais ils soulignent aussi qu’un utilisateur mal intentionné pourrait s’en servir pour fouiller un broker insuffisamment protégé.

En conclusion, la section sécurité MQTT nous apprend que **toute implémentation MQTT doit intégrer nativement la sécurité** : utiliser des brokers non sécurisés pour un produit réel serait irresponsable. Il faut donc intégrer dès la conception du système IoT les mécanismes d’authentification/chiffrement adéquats et tester l’infrastructure (via des captures réseau, etc.) pour vérifier que rien de sensible ne transite en clair.

# Autres services Cloud et IoT

Au-delà du prototype sur broker public, le cours a exploré des services cloud IoT plus aboutis, en particulier dans l’écosystème Amazon Web Services (AWS), ainsi que l’intégration des objets connectés avec des **assistants vocaux** comme Alexa ou Google Assistant.

## AWS IoT Core et Device Defender
Le service **AWS IoT Core** d’Amazon a été présenté comme un exemple de plateforme cloud IoT complète. Ce service gère la connectivité sécurisée d’objets à grande échelle. Quelques caractéristiques vues en TP :

- **Gestion des “Things”** : AWS IoT Core permet de créer des objets virtuels (appelés *Things*) représentant nos appareils physiques. Par exemple, on a enregistré notre lampe connectée comme un objet nommé “SmartLamp” dans la console AWS ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Let%E2%80%99s%20create%20our%20smart%20lamp,and%20assign%20its%20certificate)). À chaque objet, on associe un **certificat de sécurité** unique, généré par AWS (ou par une PKI interne) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Let%E2%80%99s%20create%20our%20smart%20lamp,and%20assign%20its%20certificate)). Ce certificat X.509, une fois installé sur l’appareil, servira à authentifier l’appareil auprès du broker AWS via une connexion TLS mutuelle (mTLS).
- **Broker MQTT scalable** : AWS IoT fournit un endpoint MQTT spécifique à l’instance cloud (une URL du style `<identifiant>.iot.<région>.amazonaws.com`). L’appareil (Raspberry Pi) s’y connecte en TLS sur le port 8883 en utilisant son certificat client. Ce broker supporte MQTT 3.1.1 et distribue les messages aux abonnés comme un Mosquitto classique, mais de façon hautement disponible.
- **Politiques de sécurité (IoT Policy)** : Un aspect important est qu’on peut définir des **politiques d’autorisations fines** pour chaque certificat/objet ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Then%20specify%20our%20smart%20lamp,permissions%E2%80%A6)). Par exemple, pour notre SmartLamp, on a créé une policy autorisant l’objet à publier et souscrire sur certains topics spécifiques (et rien d’autre). Ceci répond au principe de moindre privilège – même si l’appareil était compromis, il ne pourrait pas agir en dehors du périmètre qui lui est alloué. Dans le TP, pour simplifier on avait mis une policy permissive (iot:* sur *), mais on a noté qu’en production il faudrait restreindre aux topics de la lampe ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Then%20specify%20our%20smart%20lamp,permissions%E2%80%A6)).
- **Intégration aux services AWS** : AWS IoT Core a aussi une fonction de “Rules” permettant de lier les données IoT à d’autres services AWS (par ex, stocker automatiquement les messages dans DynamoDB, déclencher une fonction Lambda sur certains événements, etc.). On n’a pas détaillé cela dans le résumé, mais c’est un atout pour bâtir des applications serverless autour des objets.

En termes de sécurité, AWS IoT Core illustre une **bonne pratique** : chaque objet a une identité forte (certificat) et les échanges sont chiffrés et authentifiés d’office. **AWS Device Defender** a été présenté comme l’outil complémentaire pour la surveillance de la sécurité IoT dans le cloud AWS. Device Defender permet :

- **L’audit des configurations IoT** : il vérifie que les objets et policies respectent certaines bonnes pratiques (par ex. aucun certificat n’est trop permissif ou expiré, pas de policy “allow *” oubliée, etc.).
- **La détection d’anomalies** : il collecte des **métriques de sécurité** sur les appareils et le broker – par exemple le nombre de messages envoyés habituellement par tel appareil, les tentatives de connexion refusées, etc. ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Name%20SmartLamp_MessageSent)). En apprenant la baseline de comportement, Device Defender peut déclencher des alertes si un appareil envoie soudainement 1000 messages en une minute au lieu de 10 (signe potentiel qu’il a été compromis et spamme) ou si un appareil se connecte depuis un emplacement géographique inattendu.
- **Les alertes et remédiations** : En cas de détection, Device Defender peut créer des alarmes, notifier les administrateurs, voire initier des actions automatiques (comme détacher un certificat compromis).

Dans le TP, après avoir connecté la SmartLamp à AWS IoT, on a pu voir dans la console AWS les métriques de Device Defender liées à cet objet (par ex. le nombre de messages publiés) et comment on pourrait paramétrer des alertes sur des dépassements ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Name%20SmartLamp_MessageSent)).

On a également mentionné que d’autres grands acteurs cloud offrent des services similaires : **Google Cloud IoT Core**, **Azure IoT Hub**, **Alibaba IoT** etc., qui tous gèrent l’authentification des devices, la collecte de données, et proposent parfois des fonctionnalités de surveillance de sécurité ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Google%20Cloud%20IoT%20)). Le choix de la plateforme dépendra des affinités et de l’écosystème de l’entreprise, mais tous mettent l’accent sur la sécurisation à grande échelle (certificats, rôles, monitoring…).

## Intégration avec des assistants vocaux (Alexa, Google Assistant)
Le projet de lampe connectée a été poussé plus loin en explorant l’**intégration d’un assistant vocal** pour contrôler la lampe par la voix. En l’occurrence, c’est **Amazon Alexa** qui a été utilisé comme exemple (étant donné l’intégration naturelle avec AWS IoT), mais on a évoqué que des solutions similaires existent pour **Google Assistant**.

Concrètement, l’idée est de permettre à l’utilisateur de dire une commande du type : *« Alexa, allume la lampe du salon »*. L’assistant vocal Alexa va alors interpréter la commande et **déclencher une action sur le cloud** qui aboutira à l’allumage de notre lampe connectée. Deux approches possibles : utiliser un **Alexa Skill** personnalisé ou passer par un service “IoT” d’Alexa.

Dans le TP, on a simplifié en imaginant une Skill Alexa nommée “my PI” pour piloter le Raspberry Pi. L’utilisateur pouvait dire *« Alexa, dis à **my PI** d’allumer la lumière »* ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Alexa%20%E2%80%93%20Smart%20lamp%20use,case)). Cette Skill aurait alors appelé une fonction Lambda sur AWS, laquelle publiait un message MQTT vers notre lampe (via AWS IoT Core) pour l’allumer. L’architecture mise en place est la suivante : **Alexa** (cloud Amazon) → **AWS Lambda** (notre code backend) → **AWS IoT Core** (broker MQTT) → **Lampe** (Raspberry Pi). On a pu ainsi **contrôler la LED par la voix**. Les slides montraient l’architecture de cette intégration Alexa-lampe ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Alexa%20%E2%80%93%20Smart%20lamp%20architecture)) et un cas d’usage où Alexa sert d’interface utilisateur vocale pour l’IoT.

Cette démonstration a souligné la **convergence entre IoT et assistants vocaux**. Les enceintes connectées (Amazon Echo, Google Home) deviennent des **interfaces naturelles** pour piloter les objets de la maison (domotique). En reliant l’IoT aux API de ces assistants, on peut créer des expériences utilisateur fluides. Google Assistant aurait un fonctionnement similaire via la plateforme **Google Home / Google Cloud**. Typiquement, Google propose son service **Google Actions** (équivalent des Alexa Skills) et son cloud IoT, qu’on aurait pu utiliser de la même manière pour envoyer des commandes à la lampe.

Il a toutefois été mentionné en filigrane que cette intégration pose aussi des questions de sécurité : ouvrir un objet à des commandes vocales nécessite de bien authentifier l’émetteur (ici Alexa, via le cloud – ça va, mais attention aux Skills malveillantes) et de gérer les droits (toute personne dans la pièce peut-elle contrôler la lampe ? Quid d’une voix imitée ?). On a cité par exemple des recherches montrant que des **lasers pointés sur un micro d’Amazon Echo ou Google Home peuvent déclencher des commandes** à l’insu de l’utilisateur ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=252https%3A%2F%2Fwww.wired.com%2Fstory%2Flasers)). Cela dépasse un peu le cadre, mais c’est une illustration des nouveaux vecteurs d’attaque quand on connecte tout ensemble.

En conclusion, l’ouverture aux services cloud et aux assistants vocaux montre comment l’IoT s’insère dans un **écosystème plus large**. Des plateformes comme AWS IoT offrent les briques pour sécuriser et faire évoluer un prototype IoT vers un produit industriel. Les assistants vocaux, quant à eux, offrent des possibilités d’interaction innovantes mais doivent être pris en compte dans l’analyse de sécurité globale (qui aurait pensé qu’une lampe devrait se protéger contre des attaques laser sur un assistant vocal ?). Le cours nous a donc exposés à ces dimensions afin d’avoir une vision d’ensemble des **opportunités** et des **défis** de l’IoT connecté aux services cloud et AI.

# Cas pratiques et exercices

Enfin, le cours s’est conclu par une série de **cas pratiques et exercices** visant à consolider les connaissances. Ces exercices ont permis de manipuler concrètement les outils IoT et de réfléchir à la sécurité. Parmi ceux-ci :

## Expérimentations avec Mosquitto, MQTTBox et Node-RED
Dans un premier temps, on a réalisé des expérimentations simples pour bien comprendre le fonctionnement de **MQTT**. On a utilisé les outils suivants :

- **Mosquitto** : on a exploité le broker public Mosquitto (`test.mosquitto.org`) comme terrain de jeu. L’idée était de se connecter à ce broker open et d’y échanger des messages.
- **MQTTBox** : c’est un client MQTT graphique, disponible en application (ou extension Chrome), qui facilite les tests. On a installé MQTTBox sur nos PC ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Install%20MQTT%20Box%20desktop,fr%26gl%3Dfr%20%2F%20https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fmqttbox%2Fkaajoficamnjijhkeomgfljpicifbk%20af%3Fhl%3Dfr)). Puis on a créé **plusieurs clients MQTT** dans MQTTBox, chacun se connectant à un broker de test différent (Mosquitto public, le broker public de HiveMQ, et MQTTDashboard) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=%E2%80%A2%20Connecting%20to%20Mosquitto%20open,broker)). Une fois connectés, on a pu **publier des messages** sur un topic commun (par ex. `coursIoT/test`) et voir les autres les recevoir en temps réel, validant le principe pub/sub. On a également testé les wildcard en s’abonnant à `coursIoT/#` pour recevoir tous les sous-topics. C’était un moyen ludique de se familiariser avec la syntaxe MQTT et d’observer les échanges.
- **Node-RED** : on a aussi utilisé Node-RED comme client MQTT, en profitant de ses nœuds prêts à l’emploi. Par exemple, on a monté un flux Node-RED où un nœud **MQTT in** était abonné au topic `#` (tout) sur le broker public, et relié à un nœud **debug** pour afficher tous les messages reçus. En parallèle, un nœud **MQTT out** permettait d’envoyer des messages sur un topic donné. Grâce à cette configuration, Node-RED est devenu un **espion universel** du broker : on voyait défiler dans sa console tous les messages publiés par tous les utilisateurs connectés au broker public (ce qui, comme discuté, soulève des enjeux de vie privée!).

Ces manipulations ont renforcé la compréhension de comment se comportent les clients MQTT et mis en évidence l’absence de sécurité par défaut sur un broker ouvert.

## Mise en place d’un broker MQTT personnel (Shiftr.io)
Ensuite, on a découvert **Shiftr.io**, un service en ligne offrant un **broker MQTT personnel et visualisable**. Shiftr.io propose deux modes : un broker cloud hébergé sur leur site, et la possibilité de télécharger un broker local. Nous avons opté pour la version cloud gratuite. Les étapes réalisées :

- **Création d’un compte et d’une instance** : on s’est inscrit sur le site *cloud.shiftr.io* et on a créé une nouvelle **instance de broker MQTT privée** ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Shiftr.io%20,io)). On a choisi un nom d’instance, ce qui nous a donné une URL du type `monNom.cloud.shiftr.io`. Shiftr.io a généré pour cette instance un **login** (identifiant) et un **token** (servant de mot de passe) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=mqtt%3A%2F%2FmyLogin%3AmyToken%40myLogin)).
- **Connexion à l’instance** : via l’interface web Shiftr, on peut se connecter et observer les messages. Mais on a aussi testé l’envoi de messages vers notre broker Shiftr en utilisant l’outil en ligne de commande **mosquitto_pub**. Par exemple, depuis le Raspberry Pi on a exécuté :
```bash
mosquitto_pub -h monNom.cloud.shiftr.io -u monLogin -P monToken -t 'Test' -m 'HELLO'
```
pour publier "HELLO" sur le topic `Test` ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=mqtt%3A%2F%2FmyLogin%3AmyToken%40myLogin)). On a pu voir ce message apparaître dans l’interface web Shiftr en temps réel, ce qui était assez satisfaisant. De même, on pouvait ajouter un nœud MQTT dans Node-RED pointant vers `monNom.cloud.shiftr.io` avec les bons identifiants, pour intégrer ce broker dans nos flux.

- **Visualisation et debug** : l’interface Shiftr.io affiche graphiquement les topics sous forme de bulles qui s’animent à chaque message, ce qui aide à comprendre qui envoie quoi. C’est un outil très pédagogique pour observer les échanges MQTT et vérifier que tout fonctionne comme prévu. On a ainsi utilisé Shiftr pour debugger nos publications.

Cet exercice a montré comment déployer en quelques clics un **broker MQTT personnel sur le cloud**, avec un accès restreint (login/token) – c’est déjà un net progrès par rapport aux brokers publics ouverts. Bien sûr, pour une solution de production, on préférerait un broker auto-hébergé ou un cloud plus robuste, mais Shiftr est idéal pour expérimenter en sécurité (d’autant qu’on peut le passer en TLS aussi si besoin).

## Analyse de la sécurité des messages MQTT publics
Un des ateliers les plus instructifs a consisté à **analyser le flot de messages circulant sur un broker public** afin d’illustrer concrètement les problèmes de sécurité évoqués plus tôt. Pour cela, on a monté un petit dispositif de type *honeypot* :

- On a configuré Node-RED pour qu’il s’abonne à **tous les topics** (`#`) sur le broker public **MQTT Dashboard** (broker.mqttdashboard.com) ou HiveMQ public.
- On a ensuite relié ce flux à notre broker Shiftr.io, en gros on a fait un **pont MQTT** : chaque message reçu du broker public était instantanément **republié** sur notre broker privé Shiftr ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=broker)). Techniquement, cela se fait en Node-RED en ayant un nœud MQTT in (souscrit à `#` sur mqttdashboard) relié à un nœud MQTT out (pointant vers monNom.cloud.shiftr.io, sans spécifier de topic pour reprendre le même que celui reçu) ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=broker)).

- Résultat : sur l’interface Shiftr, on voyait apparaître **tous les topics et messages** qui transitaient sur le broker public, comme si on “aspirait” son contenu ((file://file-Mgr1xvHsLKPWaW3vbJwy9D#:~:text=Shiftr,let%E2%80%99s%20go%20fishing)). C’était assez édifiant de voir la quantité de données partagées ouvertement. On a pu observer par exemple des messages de capteurs météo, des états de machines, parfois des messages texte de tests… Dans certains cas, des noms de topics évoquaient des entreprises ou des projets réels, ce qui laisse penser que certains laissent involontairement des systèmes de test connectés en production sur ces brokers publics.

- On a discuté des implications : si nous, en quelques minutes, avons pu intercepter ces données, un acteur malveillant pourrait en faire autant sur une plus longue durée et peut-être reconstituer des informations sensibles (ex: horaires de présence si des capteurs de mouvement publient en clair, etc.). Voire, si des commandes passent par là, il pourrait essayer d’en injecter.

Ce **“fishing” de messages MQTT publics** a été un exercice marquant pour comprendre que la **sécurité par l’obscurité n’est pas une stratégie** : publier sur un broker sans authentification en se disant que “personne ne saura” est illusoire – il est trivial de tout écouter.

Pour conclure cette partie pratique, les enseignants ont insisté sur le fait que ces exercices visaient à reproduire, à petite échelle, ce que des attaquants font à grande échelle. D’où l’importance, encore une fois, de ne **jamais laisser un objet connecté communiquer en clair sur des canaux publics** au-delà de simples démonstrations. Chaque projet IoT doit intégrer dès sa phase de prototypage une réflexion sur le **confinement des données** et la **sécurisation des échanges**, faute de quoi on expose potentiellement des informations ou un contrôle à des personnes non autorisées.
