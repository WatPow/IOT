# Projet pratique : Création d’une lampe connectée

Dans le cadre du cours, un **projet pratique** a été réalisé pour appliquer concrètement ces notions : la création d’une **lampe connectée intelligente** (smart lamp). L’objectif était de monter un prototype de lampe pilotable localement et à distance, avec une interface web et même un contrôle vocal, en mettant l’accent sur la sécurité à chaque étape. Voici les grandes étapes de ce projet :

## Installation et configuration du Raspberry Pi
On a choisi d’utiliser un **Raspberry Pi** comme cœur de la lampe (ce choix de matériel a été posé dès le départ pour le prototype, bien qu’une version finale aurait pu utiliser un microcontrôleur plus simple). La première étape a consisté à préparer le Raspberry Pi : on a **installé le système d’exploitation Raspbian (Raspberry Pi OS)** sur une carte SD. Pour cela, l’outil Raspberry Pi Imager a été utilisé avec l’image officielle du système.

Une fois le système copié, on a inséré la carte SD et démarré le Pi. **L’accès SSH a été activé** pour pouvoir configurer le Pi sans écran (mode headless). Cela s’est fait soit via l’option dédiée dans l’Imager, soit manuellement en plaçant un fichier vide nommé `ssh` à la racine de la partition boot sur la carte SD avant le premier démarrage. Ainsi, on peut se connecter à distance en ligne de commande. On a également configuré la **connexion réseau Wi-Fi** en créant un fichier de configuration `wpa_supplicant.conf` (contenant le SSID et mot de passe du réseau sans fil) dans la partition de boot. Cette configuration permettait au Raspberry Pi de se connecter automatiquement à internet. Après le démarrage, on s’est connecté en SSH avec les **identifiants par défaut** (login `pi` / mot de passe `raspberry`), puis il est recommandé de changer le mot de passe par sécurité.

Côté matériel, on a **assemblé les composants de la lampe** : le Raspberry Pi, une LED (qui simulera l’ampoule de la lampe) et un bouton poussoir (pour contrôler la lampe manuellement). La LED a été branchée sur l’une des broches GPIO du Raspberry Pi (avec une résistance en série), et le bouton sur une autre broche GPIO configurée en entrée (avec une résistance de pull-up/down adaptée). En résumé, à l’issue de cette phase, on disposait d’un Raspberry Pi opérationnel (OS installé, accessible à distance) avec une LED et un bouton connectés à ses broches d’E/S.

## Gestion des GPIO (LED et bouton-poussoir)
La seconde étape a porté sur la **validation de la partie électronique** : il fallait s’assurer qu’on pouvait allumer la LED et lire l’état du bouton via le Raspberry Pi. Pour cela, on a manipulé les **GPIO** (General Purpose Input/Output) du Pi.

Dans un premier temps, on a utilisé un petit script Python en se connectant en SSH. Grâce à la bibliothèque Python `RPi.GPIO`, on peut contrôler les broches programmables. On a écrit un programme qui configure la broche reliée à la LED en **sortie**, puis qui envoie successivement un niveau haut (3.3V) ou bas (0V) sur cette broche. Concrètement, un appel à `GPIO.output(pin, GPIO.HIGH)` allume la LED, et `GPIO.output(pin, GPIO.LOW)` l’éteint. En faisant alterner ces états avec une pause d’une seconde (fonction `sleep`), on obtient un **clignotement de la LED** en boucle, ce qui valide que la lampe peut être contrôlée par logiciel. Ce test (un programme *blink*) est un grand classique pour s’assurer du bon câblage et de la configuration de la bibliothèque GPIO.

De même, on a testé le **bouton poussoir** en configurant la broche correspondante en **entrée** avec résistance de pull-up interne activée. Un court script permettait de lire la valeur de la broche (0 ou 1 selon l’état du bouton) et d’afficher un message lors d’un appui. Cela nous a permis de confirmer que le Raspberry Pi détecte correctement les pressions sur le bouton.

En parallèle du code Python, le projet a introduit l’outil **Node-RED** pour gérer les GPIO de façon plus visuelle. Node-RED est un environnement de programmation par flux (flow-based) accessible via un navigateur web. Dans Node-RED, on a ajouté des **nœuds spécifiques Raspberry Pi** : un nœud d’entrée GPIO configuré sur la broche du bouton, et un nœud de sortie GPIO sur la broche de la LED. En les connectant, on peut lier le bouton à la LED : chaque changement d’état du bouton déclenche automatiquement l’allumage ou l’extinction de la LED. Node-RED offre également des **noeuds “inject”** (pour envoyer manuellement des signaux) et des **noeuds “dashboard”** pour créer une interface utilisateur. On a ainsi pu ajouter deux boutons virtuels (dans une interface web tableau de bord) reliés à la LED : l’un pour allumer, l’autre pour éteindre. En quelques clics, on avait une **interface de contrôle locale** de la lampe, sans avoir encore codé d’application web – Node-RED s’en charge.

À ce stade, le matériel de la lampe était opérationnel et pilotable localement : le Raspberry Pi faisait office de contrôleur, le bouton physique permettait de changer l’état de la lampe, et une LED reflétait cet état (éclairée ou non).

## Programmation en Python et Node-RED
Une fois la communication de base avec la lampe établie, l’étape suivante a consisté à **développer la logique applicative** de la lampe connectée. Deux approches ont été explorées : la programmation par code (Python) et la programmation par flux (Node-RED), chacune ayant ses bénéfices.

Dans un premier temps, on a étendu le **script Python** pour gérer une logique un peu plus avancée : par exemple, alterner l’état de la LED à chaque appui sur le bouton (toggle), ou faire clignoter la lumière en morse. Cela permet d’illustrer comment on pourrait écrire le programme embarqué de l’objet. Toutefois, écrire tout en Python peut devenir complexe pour intégrer d’autres fonctionnalités (comme une interface graphique ou un service web). C’est pourquoi le projet a basculé vers Node-RED pour la suite.

**Node-RED** a été utilisé comme principal outil de construction de l’application IoT de la lampe. Dans Node-RED, on a créé un **flux** représentant le comportement de la lampe :
- Le nœud d’entrée du bouton est relié à un nœud fonction (ou directement à un nœud de sortie) de manière à inverser l’état de la LED à chaque appui.
- Des **nœuds temporisés** peuvent être ajoutés pour, par exemple, éteindre automatiquement la lampe après un certain temps (fonction de minuterie).
- Grâce aux **nœuds Dashboard**, on a construit une petite interface utilisateur web : un bouton “Allumer/Éteindre” qui envoie une commande, et une indication visuelle de l’état actuel de la lampe (par ex. une LED virtuelle verte/rouge). Node-RED héberge ce tableau de bord accessible via un navigateur sur le réseau local du Raspberry Pi.

L’avantage de Node-RED est qu’il permet d’intégrer facilement divers **protocoles et services** sans avoir à coder tout à bas niveau. Par exemple, on peut insérer un nœud HTTP, un nœud MQTT, un nœud base de données, et les relier. Cela a été utile pour les étapes suivantes du projet. Notons que l’équipe a choisi Node-RED justement pour **éviter de développer une application mobile dédiée** et privilégier un accès via le navigateur : cette décision a accéléré le développement (pas de code Android/iOS à écrire) et Node-RED fournit d’emblée un tableau de bord web en LAN.

En résumé, à l’issue de cette phase de programmation, la “smart lamp” disposait d’une logique interne et d’une interface locale : on pouvait appuyer sur le bouton ou cliquer sur l’interface web locale pour allumer/éteindre la LED, et le système pouvait éventuellement effectuer des actions automatiques (timer, etc.) configurées dans Node-RED.

## Ajout de contrôle distant via MQTT
La fonctionnalité suivante à implémenter était le **contrôle à distance** de la lampe, c’est-à-dire la possibilité d’agir sur la lampe depuis l’extérieur du réseau local, voire depuis Internet. Pour ce faire, on a intégré le protocole **MQTT** dans la solution.

Le principe a été le suivant : le Raspberry Pi (et Node-RED) fonctionnent comme un **client MQTT** qui s’abonne à un certain **topic** pour les commandes de la lampe. Par exemple, un topic nommé `lampe/commande` ou `RPI1/lampe/setState`. Lorsqu’un message “ON” ou “OFF” est publié sur ce topic par n’importe quel autre client MQTT, le Raspberry Pi le reçoit et Node-RED déclenche l’allumage ou l’extinction de la LED en conséquence. Inversement, le Raspberry Pi peut publier sur un topic (ex: `lampe/etat` ou `RPI1/lampe/status`) à chaque changement, afin que les clients distants soient informés de l’état actuel de la lampe.

Pour réaliser cela, il a fallu disposer d’un **broker MQTT** accessible par tous les clients (le Raspberry Pi et le client distant). Dans un premier temps, pour simplifier, on a utilisé un **broker public gratuit** comme **Mosquitto** en ligne (par exemple `test.mosquitto.org` sur le port 1883) – ces brokers ouverts permettent de tester sans installer de serveur. On a configuré Node-RED pour qu’il se connecte à ce broker en tant que client MQTT (Node-RED offre des nœuds “MQTT input” et “MQTT output” prêts à l’emploi). Le nœud MQTT input a été paramétré avec le topic de commande de la lampe et relié au nœud de sortie GPIO de la LED. Ainsi, toute commande reçue sur le broker est transmise au flux Node-RED et agit sur la LED.

Côté utilisateur distant, on pouvait utiliser un outil comme **MQTTBox** sur PC ou smartphone pour se connecter au même broker et envoyer des messages MQTT. En pratique, en se connectant au broker `test.mosquitto.org` et en publiant le message `ON` sur le topic convenu, on voyait instantanément la LED de la lampe s’allumer à distance. Cela a validé le concept de **pilotage à distance par Internet** grâce à MQTT.

MQTT présente l’avantage d’être léger et **découple l’expéditeur du destinataire** : le Raspberry Pi n’a pas besoin d’être directement exposé sur Internet, c’est le broker qui sert de point central de communication. Le Pi maintient juste une connexion sortante vers le broker, et peut ainsi recevoir des ordres de n’importe où. De plus, MQTT gère les problèmes de connectivité (si la connexion est perdue, le Pi se reconnectera et pourra récupérer un message *retain* s’il a été marqué comme tel, etc.).

Cette étape a transformé notre lampe locale en **objet connecté à part entière** : on pouvait la contrôler depuis un réseau extérieur via le broker MQTT. On avait ainsi une infrastructure simple : *lampe (Raspberry Pi) ←MQTT→ broker (cloud) ←MQTT→ client distant*.

Enfin, on a aussi fait en sorte de **publier l’état** de la lampe sur un topic MQTT dédié. Ainsi, le client distant pouvait s’abonner et être notifié (par ex. recevoir “ON” ou “OFF” quand quelqu’un appuie sur le bouton physique). Cela permet une synchronisation dans les deux sens.

À ce stade, la “smart lamp” couvrait toutes les fonctionnalités de base : **contrôle local manuel, interface web locale, et contrôle distant via MQTT**. La suite du projet a porté sur l’amélioration de la **sécurité** et l’intégration avec des services cloud plus avancés.
