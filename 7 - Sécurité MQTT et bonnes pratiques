# Sécurité MQTT et bonnes pratiques

L’utilisation de MQTT dans un contexte IoT nécessite de bien comprendre les enjeux de sécurité, notamment quand on utilise des brokers publics ou partagés. Le cours a abordé les **risques liés aux brokers MQTT ouverts** et les **bonnes pratiques pour sécuriser les communications MQTT**. Des exercices pratiques ont également été menés, notamment avec **Wireshark et TCPDump** pour analyser le trafic.

## Vulnérabilités des brokers MQTT publics
Les brokers MQTT publics (tels que `test.mosquitto.org`, `broker.hivemq.com`, etc.) sont très utiles pour tester rapidement, car ils sont ouverts à tous sans inscription. Cependant, ils présentent de **graves vulnérabilités du point de vue sécurité** :

- **Absence d’authentification** : N’importe quel client peut se connecter anonymement sur ces brokers et s’abonner à n’importe quel topic. Il n’y a généralement **aucun contrôle d’accès** par défaut. Un attaquant peut donc écouter des topics courants (souvent les gens testent sur des topics comme “test” ou “dev”) et potentiellement capter des informations sensibles si des utilisateurs y envoient des données privées par inadvertance. Il peut aussi publier des messages malveillants sur des topics utilisés par d’autres.
- **Données en clair sur le réseau** : Souvent, les connexions se font sur le port MQTT standard (1883) qui n’est **pas chiffré**. Les messages circulent donc en clair sur Internet. Via une simple capture réseau, un attaquant peut lire le contenu des messages MQTT échangés sur un broker public. Si des identifiants ou commandes critiques transitent, ils sont exposés. Un exercice a consisté à lancer **TCPDump** sur le port 1883 pour capturer le trafic MQTT, puis à publier un message avec nom d’utilisateur et mot de passe en paramètre sur un broker public – on a pu voir en clair le contenu du message et les identifiants transmis, preuve qu’il n’y a pas de confidentialité sans TLS.
- **Pas de cloisonnement entre clients** : Sur un broker public, un client malveillant peut s’abonner à `#` (wildcard qui reçoit tous les topics) et **espionner l’intégralité du trafic** passant par ce broker. De plus, il peut utiliser un identifiant client identique à celui d’un autre device pour le déconnecter (puisqu’un broker MQTT déconnecte le précédent client si un autre se connecte avec le même ClientID) – c’est une façon de faire du **denial of service ciblé** sur un device.

En somme, les brokers ouverts sont *intrafiquables* et à utiliser uniquement pour des tests sans données réelles. Dans un contexte de production, laisser des objets se connecter à un broker public représenterait un énorme risque (données lisibles par tous, contrôle possible par des tiers). Le cours a illustré ces vulnérabilités pour bien faire prendre conscience qu’il fallait impérativement passer à des solutions sécurisées.

## Authentification et chiffrement des communications MQTT
Pour sécuriser MQTT, deux axes principaux : **authentifier** les clients et **chiffrer** les échanges. Les bonnes pratiques présentées incluent :

- **Utilisation d’un broker privé ou sécurisé** : Plutôt que d’utiliser un broker public anonyme, déployer son propre broker MQTT ou utiliser un service cloud IoT qui impose une sécurité. Cela permet de **contrôler qui se connecte**. Par exemple, un broker Mosquitto peut être configuré avec une liste d’utilisateurs/mots de passe, ou (mieux) avec des certificats clients. Un service comme AWS IoT Core oblige chaque appareil à présenter un **certificat X.509 valide** pour s’authentifier.
- **Mise en place d’une authentification MQTT** : MQTT supporte l’envoi d’un nom d’utilisateur et mot de passe lors de la connexion (champ `CONNECT`). Sur un broker privé, on configurera donc des **identifiants uniques par appareil**. Cependant, l’envoi de login/password en clair n’est pas suffisant – il doit être couplé à du chiffrement TLS pour ne pas exposer ces credentials sur le réseau. Idéalement, l’utilisation de **certificats** rend l’authentification encore plus robuste (impossibilité de se connecter sans posséder la clé privée de l’appareil). Un bon broker doit aussi implémenter des **ACL (Access Control Lists)** pour n’autoriser chaque client qu’à publier/souscrire à certains topics spécifiques, évitant qu’un appareil puisse interférer avec un autre.
- **Chiffrement via TLS** : Il est indispensable de **chiffrer les communications MQTT** surtout si elles passent par Internet. MQTT peut aisément fonctionner sur TLS (port par défaut 8883). Ainsi, tous les messages sont cryptés et ne peuvent être lus par un intermédiaire. Le cours a montré que sans TLS on peut tout voir dans Wireshark, alors qu’avec TLS, même en capturant le trafic, on ne voit que des données chiffrées. De plus, TLS garantit l’authenticité du serveur (le client vérifie le certificat du broker) et éventuellement l’authenticité du client (si on utilise des certificats clients). On a évoqué l’usage de **MQTTS** (MQTT over SSL/TLS) à privilégier systématiquement.

En résumé, les communications de la lampe connectée auraient dû, dans une version sécurisée, passer par un broker MQTT avec authentification + TLS. C’est d’ailleurs le cas sur les plateformes cloud professionnelles : **AWS IoT exige une connexion TLS avec certificat**, et ne permet pas de se connecter en clair ou anonymement. Cette combinaison d’authentification forte et de chiffrement assure que seuls les clients autorisés échangent, et de façon confidentielle.

## Captures réseau et analyse du trafic MQTT
Pour sensibiliser aux points ci-dessus, le cours a inclus des manipulations avec **Wireshark** et **tcpdump**. Concrètement, après avoir fait échanger des messages MQTT entre la lampe (Raspberry Pi) et le broker public, on a **capturé le trafic réseau** sur le Raspberry Pi en écoutant le port 1883 (port MQTT non sécurisé). L’analyse avec Wireshark a permis d’observer dans les paquets :

- Les messages PUBLISH contenant le topic et le payload en clair (on voyait par exemple le texte “HELLO” ou “Message1” envoyé sur le topic de test).
- Les éventuels identifiants envoyés lors du CONNECT (si on avait configuré un user/password dans MQTTBox, ils apparaissaient en clair dans le paquet.

Cet exercice a clairement montré que **sans chiffrement TLS, il n’y a aucune confidentialité** : un attaquant sur le même réseau (ou un administrateur de réseau) peut espionner tout le contenu. Par la même occasion, on voit qu’il serait facile d’injecter un faux message en reproduisant le même format.

Ensuite, on a refait l’essai en se connectant via **MQTTS (port 8883)** sur un broker offrant TLS. Dans ce cas, Wireshark ne permet plus de lire le contenu des paquets (il voit bien le flux TLS mais ne peut le déchiffrer). On comprend donc l’importance du chiffrement.

Enfin, il a été mentionné des outils spécialisés, par exemple **MQTT Explorer** ou **MQTT Spy**, qui permettent de se connecter aux brokers et visualiser les topics de façon arborescente. Ces outils sont pratiques pour le débogage, mais ils soulignent aussi qu’un utilisateur mal intentionné pourrait s’en servir pour fouiller un broker insuffisamment protégé.

En conclusion, la section sécurité MQTT nous apprend que **toute implémentation MQTT doit intégrer nativement la sécurité** : utiliser des brokers non sécurisés pour un produit réel serait irresponsable. Il faut donc intégrer dès la conception du système IoT les mécanismes d’authentification/chiffrement adéquats et tester l’infrastructure (via des captures réseau, etc.) pour vérifier que rien de sensible ne transite en clair.
