# Choix techniques à considérer pour un projet IoT

La conception d’un projet IoT implique de **nombreux choix techniques initiaux** qui orienteront le développement. Dès le départ, l’équipe doit décider : *Quel matériel utiliser ? Quel système d’exploitation embarqué ? Quelle connectivité et quels protocoles de communication adopter ? Faut-il s’appuyer sur une plateforme cloud ou développer une solution locale ?*. Ces décisions sont cruciales, car elles doivent équilibrer contraintes techniques, coûts, et exigences du cas d’usage.

## Matériel (Raspberry Pi, microcontrôleur…)
Le **choix du hardware** détermine les capacités de l’objet connecté. Deux grandes options existent :
- **Systèmes embarqués « complets »** : par ex. une carte Raspberry Pi, un BeagleBone ou autre nano-ordinateur capable d’exécuter un OS comme Linux. Ces plateformes offrent davantage de puissance de calcul, de mémoire et de fonctionnalités (connectivité Wi-Fi/Ethernet intégrée, ports USB, etc.). Elles facilitent le développement (on peut coder en Python, utiliser des services existants) et la mise en place de mécanismes de sécurité complexes. En contrepartie, elles consomment plus d’énergie et coûtent plus cher.
- **Microcontrôleurs (MCU)** : par ex. une carte Arduino, un module ESP8266/ESP32, un STM32 Nucleo, etc. Ces modules sont très économiques et basse consommation, mais beaucoup plus limités en ressources (quelques dizaines de MHz, peu de RAM/stockage). Ils n’exécutent généralement pas Linux mais du code natif ou un petit RTOS. Le développement est plus contraint (souvent en C/C++) et certaines fonctionnalités doivent être implémentées manuellement (pile réseau, crypto...). Toutefois, il existe des microcontrôleurs spécialisés IoT avec des accélérateurs cryptographiques ou des éléments sécurisés (Secure Elements) pour aider à la sécurité.

Le choix dépend du cas d’usage : si l’objet doit faire des traitements locaux avancés ou supporter une pile logicielle lourde, un **nano-ordinateur type Raspberry Pi** est indiqué. S’il doit être très économe, peu coûteux et en grand nombre, un **MCU** sera préféré. Parfois, un compromis consiste à utiliser un SoC intermédiaire (ex: ESP32 qui offre Wi-Fi + assez de RAM pour du SSL). Quoi qu’il en soit, il faut prévoir le hardware en considérant la sécurité : disponibilité d’un **TPM/élément sécurisé** pour stocker des clés, support d’accélération de chiffrement, etc., peuvent influencer la décision.

## Systèmes d’exploitation (Linux, RTOS…)
En parallèle du matériel, le **système d’exploitation (OS)** embarqué doit être choisi. Là aussi, plusieurs catégories :
- **Pas d’OS (bare metal)** : le microcontrôleur exécute une boucle logicielle directement sans couche d’abstraction. C’est le cas des petits Arduino classiques par exemple. Cela offre un contrôle total et une faible overhead, mais complique la gestion de fonctionnalités complexes (pas de multitâche sauf à implémenter un scheduler rudimentaire, gestion manuelle du réseau…).
- **OS temps réel léger (RTOS)** : de nombreux microcontrôleurs IoT adoptent un RTOS (Real-Time Operating System) comme **FreeRTOS**, **ARM mBed OS**, **Zephyr**, etc. Ces OS apportent un ordonnancement de tâches, des bibliothèques pour la communication (pile TCP/IP, drivers) et parfois des *frameworks* IoT intégrés. Ils sont conçus pour tourner avec très peu de mémoire et pour respecter des contraintes temps réel (délais garantis pour certaines tâches). L’avantage est d’avoir une base logicielle fiable et modulable, tout en restant adapté aux ressources limitées.
- **Linux embarqué** : si le hardware le permet (processeur ARM Cortex-A par ex.), on peut embarquer un OS Linux (comme Raspbian sur Raspberry Pi). Linux offre un écosystème riche, la compatibilité avec de nombreux protocoles et bibliothèques, et la facilité de développement (on peut coder en haut niveau, utiliser Python, Node.js, etc.). Des distributions spécialisées IoT ou minimalistes existent. Cependant, Linux a un empreinte mémoire/stockage bien plus grande et peut introduire des soucis de stabilité temps réel ou de temps de boot.
- **OS spécialisés** : il existe des OS plus rares selon les besoins, par ex. **PikeOS** (système partitionné sûr) pour des applications critiques, ou des OS propriétaires optimisés pour l’IoT.

Le choix de l’OS se fait en fonction des **ressources matérielles disponibles** et des **exigences de l’application**. Un petit capteur sur batterie utilisera plutôt un firmware bare metal ou un RTOS ultra-léger. Un gateway ou un appareil multi-capteurs pourra embarquer Linux pour bénéficier de sa polyvalence. D’un point de vue sécurité, Linux apporte les mécanismes éprouvés (gestion d’utilisateurs, droits, mises à jour facilitées) tandis qu’un firmware bare metal offre une surface d’attaque plus réduite mais nécessite de tout implémenter à la main (y compris les sécurités). Souvent, la facilité de déploiement oriente le choix : beaucoup de développeurs prototypent avec Raspberry Pi + Linux pour aller vite, puis éventuellement optimisent vers un MCU/RTOS pour la version industrielle.

## Protocoles de communication (MQTT, CoAP, HTTP…)
Plusieurs **protocoles réseau** sont envisageables pour la communication entre l’objet et la plateforme serveur. Les principaux protocoles applicatifs utilisés en IoT incluent :

- **MQTT (Message Queuing Telemetry Transport)** – Un protocole de messagerie léger basé sur un modèle **Publish/Subscribe**. Les objets envoient des messages (publish) sur des *topics* et reçoivent des messages en s’abonnant (subscribe) à des topics d’intérêt. MQTT est très économe en bande passante et en ressources, utilisant un format binaire simple sur TCP. Il nécessite un **broker** (serveur MQTT) faisant office d’intermédiaire : les clients ne communiquent jamais directement entre eux, tout passe par le broker qui redistribue aux abonnés. MQTT est idéal pour l’IoT : il a été conçu pour des capteurs contraints et des réseaux instables. Il offre en plus des fonctionnalités utiles (qualité de service des messages 0, 1, 2 ; rétention de messages ; topics hiérarchiques avec wildcards). De nombreux *clouds IoT* le supportent nativement.
- **CoAP (Constrained Application Protocol)** – Un protocole inspiré de HTTP mais allégé, conçu pour les dispositifs contraints et les réseaux à forte latence. CoAP fonctionne généralement sur UDP (plutôt que TCP) pour plus de légèreté. Il utilise un schéma de requête/réponse (comme HTTP REST) mais avec un en-tête binaire très compact, ce qui le rend beaucoup moins verbeux qu’HTTP classique. CoAP convient bien aux architectures *machine-to-machine* simples, et il est souvent utilisé avec l’architecture RESTful (accès à des ressources identifiées par des URI sur l’objet, par ex. `/capteur/temperature`). Il intègre des mécanismes de fiabilité (accusés de réception) malgré UDP, et peut être chiffré via DTLS.
- **HTTP/HTTPS** – Le protocole web classique est aussi utilisé en IoT, surtout lorsque les objets ont la puissance suffisante pour l’embarquer. L’avantage est la **simplicité** et l’interopérabilité : un objet peut envoyer des requêtes HTTP (par ex. POST de ses données JSON vers un serveur web) ou exposer lui-même une API REST accessible en HTTP. Cependant, HTTP est plus **lourd** en overhead (entêtes texte volumineux) et moins adapté aux réseaux limités. Sur des microcontrôleurs, implémenter HTTP et TLS consomme davantage de mémoire. Néanmoins, pour des objets connectés en haut débit (Ethernet, Wi-Fi) et pour réutiliser l’infrastructure web existante, HTTP(S) reste un choix courant.

D’autres protocoles ou standards IoT peuvent être mentionnés selon les besoins : par exemple **WebSockets** (communication bidirectionnelle temps réel sur une base HTTP, utile pour des retours instantanés), **AMQP** (protocole de messagerie orienté broker, plus lourd que MQTT, plutôt pour l’IoT industriel), ou encore des *suites* comme **LwM2M** (Lightweight M2M) qui combinent CoAP et un modèle d’objets pour faciliter la gestion de dispositifs à distance.

En pratique, **MQTT s’est imposé** pour de nombreux cas d’usage IoT grand public et industriel, grâce à sa légèreté et son modèle pub/sub découplant les émetteurs des récepteurs. CoAP est utilisé dans certains réseaux capillaires (notamment dans les objets contraints type capteurs sur batterie). HTTP reste pertinent pour l’intégration avec le web ou pour des prototypes rapides. Le choix du protocole dépendra donc des contraintes de l’objet (peut-il supporter TCP, TLS ?), du modèle d’échange requis (asynchrone pub/sub vs requête/réponse), et de l’écosystème (compatibilité avec le serveur ou la plateforme choisie). Souvent, les plateformes cloud imposent ou recommandent un protocole supporté (ex: AWS IoT Core privilégie MQTT, d’autres offrent HTTP en alternative pour les objets qui ne peuvent pas faire MQTT).

## Cloud vs solutions sur site
Enfin, un choix structurant pour une solution IoT est **l’infrastructure backend** : va-t-on s’appuyer sur un service cloud existant ou bâtir une solution locale dédiée (*on-premise*) ? Chacune des deux approches a ses avantages et inconvénients :

- **Cloud IoT** : Utiliser un cloud public (AWS, Azure, Google Cloud IoT, etc.) permet de bénéficier de **services prêts à l’emploi** : gestion des appareils (device registry), broker MQTT scalable, stockage des données, tableaux de bord, analyses, etc. Par exemple, AWS IoT Core fournit d’emblée une infrastructure fiable pour connecter des millions d’appareils de façon sécurisée. Le cloud offre **évolutivité** (on peut monter en charge facilement) et disponibilité, sans avoir à gérer le matériel serveur. De plus, il s’intègre avec d’autres services (base de données, IA, notification) offrant un écosystème complet. En revanche, le cloud implique des **coûts récurrents** (facturation à l’usage), et une **dépendance vis-à-vis d’un fournisseur** – on confie ses données et la disponibilité du service à un tiers. Des enjeux de **souveraineté des données** ou de confidentialité peuvent également se poser, en particulier dans des secteurs sensibles.
- **Solution sur site (on-premise)** : Cela consiste à héberger soi-même le serveur IoT (par ex. un broker MQTT Mosquitto sur un serveur local, une base de données interne, etc.). L’avantage principal est de garder un **contrôle total** sur l’infrastructure et les données. Aucune donnée ne transite par Internet vers un tiers si tout est local (ce qui peut réduire certains risques de confidentialité et dépendances). Les coûts peuvent être moindres à long terme pour un nombre d’appareils stable (pas de facture cloud, seulement le coût fixe des serveurs). Cependant, cette approche nécessite d’avoir les **compétences** et les ressources pour installer, développer et maintenir l’infrastructure. Il faut gérer la redondance, la sécurité, les mises à jour serveurs, etc. – ce que les clouds mutualisent pour vous. De plus, une solution sur site peut être moins accessible à grande échelle (accès distant pour les utilisateurs nomades, connectivité mondiale si les objets sont déployés sur de nombreux sites géographiques).

En pratique, beaucoup d’initiatives IoT démarrent sur des **solutions cloud** pour profiter de la rapidité de mise en œuvre et de l’**effet plateforme** (outils intégrés) – on parle de démarche MVP (Minimum Viable Product) hébergée dans le cloud pour tester rapidement. Par la suite, selon les besoins, on peut rapatrier sur site une partie de la solution ou opter pour un **cloud privé** (hébergé chez soi). L’essentiel est d’évaluer ce choix en fonction de critères de **coût**, de **sécurité** (réglementations, sensibilité des données) et de **compétences disponibles**. Notons qu’il existe des solutions hybrides : par ex. utiliser un cloud public pour la connectivité mais stocker certaines données critiques en local, ou encore déployer des appliances en périphérie (*edge computing*) qui traitent localement une partie des données pour limiter la dépendance au cloud. En résumé, *Cloud vs On-Prem* est un arbitrage entre **commodité/échelle** et **contrôle/souveraineté**, qui doit être tranché en accord avec la stratégie de l’entreprise et les contraintes du projet.
